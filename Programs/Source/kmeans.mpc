from Compiler.types import sint, regint, Array, MemValue
from Compiler.library import print_ln, do_while, for_range
from Compiler.util import if_else

# Base port number for client connections
PORTNUM = 14000

# Program arguments: test flag, number of clients, number of data points (n_size), 
# dimensions of data points (dim_size), and number of centroids (k_size)
test = program.args[0]
num_clients = int(program.args[1])
n_size = int(program.args[2])
dim_size = int(program.args[3])
k_size = int(program.args[4])

print_ln("Test: %s, N size: %s, Dim size: %s, K size: %s", test, n_size, dim_size, k_size)

def accept_client():
    """
    Accepts a connection from a client and retrieves the last flag from the socket.

    Returns:
        tuple: client_socket_id (regint), last (regint)
    """
    client_socket_id = accept_client_connection(PORTNUM)
    last = regint.read_from_socket(client_socket_id)
    return client_socket_id, last

def close_connections(number_clients):
    """
    Closes the connections for all clients.

    Args:
        number_clients (int): The number of clients connected.
    """
    @for_range(number_clients)
    def _(i):
        closeclientconnection(i)

def main():
    """
    Main function to handle client connections, receive data from clients, and store it in matrices.
    The function waits for all clients to connect, then receives N and K data points from each client.
    """
    # Start listening for client connections
    listen_for_clients(PORTNUM)
    print_ln("Listening for clients on base port %s", PORTNUM)

    # Arrays to store client socket IDs, client IDs, and connection status
    client_sockets = Array(num_clients, regint)
    client_ids = Array(num_clients, sint)
    seen = Array(num_clients, regint)
    seen.assign_all(0)

    # Matrices to store N and K data points from all clients
    n_dataset = Matrix(n_size * num_clients, dim_size, sint)
    k_dataset = Matrix(k_size * num_clients, dim_size, sint)

    # Loop until all clients have connected
    @do_while
    def client_connections():
        client_id, last = accept_client()
        print_ln("Client ID: %s, Last: %s", client_id, last, print_secrets=True)
        
        # Ensure client ID is within the expected range
        @if_(client_id >= num_clients)
        def _():
            print_ln("Client ID too high; aborting")
            crash()
        
        client_sockets[client_id] = client_id
        client_ids[client_id] = client_id
        seen[client_id] = 1
        return (sum(seen) < num_clients)
    
    print_ln("All clients have connected. Receiving data...")

    # Receive data from each connected client
    for i in range(num_clients):
        @if_(seen == 1)
        def receive_data():
            # Receive N data points
            print_ln("Receiving N from client %s", client_ids[i], print_secrets=True)
            for j in range(n_size):
                rx = sint.receive_from_client(dim_size, client_sockets[i])
                n_dataset[(i * n_size) + j] = rx
                n_dataset[(i * n_size) + j].print_reveal_nested()
                print_ln("N data row %s received from client %s", (i * n_size) + j, client_ids[i], print_secrets=True)

            # Receive K data points
            print_ln("Receiving K from client %s", client_ids[i], print_secrets=True)
            for k in range(k_size):
                rx = sint.receive_from_client(dim_size, client_sockets[i])
                k_dataset[(i * k_size) + k] = rx
                k_dataset[(i * k_size) + k].print_reveal_nested()
                print_ln("K data row %s received from client %s", (i * k_size) + k, client_ids[i], print_secrets=True)

    print_ln("Finished receiving data from all clients.")
    print_ln("Dataset received.")

    # Close connections to all clients
    close_connections(num_clients)

# Run the main function
main()