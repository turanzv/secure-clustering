from Compiler.types import sint, regint, Array, MemValue
from Compiler.library import print_ln, do_while, for_range
from Compiler.util import if_else
from math import log2, ceil

# Base port number for client connections
PORTNUM = 14000

# Program arguments: test flag, number of clients, number of data points (n_size), 
# dimensions of data points (dim_size), and number of centroids (k_size)
test = program.args[0]
num_clients = int(program.args[1])
n_input_size = int(program.args[2])
dim_size = int(program.args[3])
k_input_size = int(program.args[4])

k_size = k_input_size * num_clients
n_size = n_input_size * num_clients

print_ln("Test: %s | N size: %s | Dim size: %s | K size: %s", test, n_input_size, dim_size, k_input_size)

def accept_client():
    """
    Accepts a connection from a client and retrieves the last flag from the socket.
    
    Returns:
        tuple: client_socket_id (regint), last (regint)
    """
    client_socket_id = accept_client_connection(PORTNUM)
    last = regint.read_from_socket(client_socket_id)
    return client_socket_id, last

def close_connections(number_clients):
    """
    Closes the connections for all clients.

    Args:
        number_clients (int): The number of clients connected.
    """
    @for_range(number_clients)
    def _(i):
        closeclientconnection(i)

def log2_sint(x: sint, bit_length: int) -> sint:
    """
    Compute the integer part of the log2 of an `sint` using bit decomposition.

    Args:
        x: The secret-shared secret integer input.
        bit_length: The bit length of the input (must be known or assumed).

    Returns:
        sint: The integer part of log2(x).
    """
    bits = x.bit_decompose()

    # Initialize result as 0
    log2_result = sint(0)

    # Find the position of the most-significant bit set to 1
    @for_range(bit_length)
    def _(i):
        log2_result = i.if_else(bits[i], log2_result)
    
    return log2_result

def build_tree(input, tree_depth):
    """
    Builds a KD-Tree from the input data points.

    Args:
        input (Matrix): The input data points.
        tree_depth (int): The depth of the tree.
    
    Returns:
        list: The KD-Tree represented as a list of Arrays.
    """
    node_count = 2 ** (tree_depth + 1) - 1
    kd_tree = [Array(dim_size, sint) for _ in range(node_count)]

    # Stack for iterative construction of the KD-Tree
    stack = [(0, input, 0)]

    while stack:
        node_index, subset, depth = stack.pop()

        @if_(len(subset) == 1)
        def _():
            kd_tree[node_index] = subset[0]
            print_ln("Leaf Node (Index: %s):", node_index)
            kd_tree[node_index].print_reveal_nested(end=" ")
            print_ln()

        @if_(len(subset) != 1)
        def _():
            split_dim = depth % dim_size

            subset.sort(key_indices=(split_dim,), batcher=True)
            median_index = len(subset) // 2
            median_point = subset[median_index]

            kd_tree[node_index] = median_point

            print_ln("Node Index: %s | Median Index: %s", node_index, median_index)
            median_point.print_reveal_nested(end=" ")
            print_ln()

            # Create Matrices for left and right subsets
            left_subset = Matrix(median_index, dim_size, sint)
            right_subset = Matrix(median_index, dim_size, sint)

            # Copy values from subset into left_subset and right_subset
            left_ref = subset.get_part(0, median_index)
            right_ref = subset.get_part(median_index, len(subset) - median_index)

            for i in range(median_index):
                left_subset[i].assign_part_vector(left_ref[i], 0)

            for i in range(len(subset) - median_index):
                right_subset[i].assign_part_vector(right_ref[i], 0)


            print_ln("Left Subset (Depth: %s):", depth)
            for a in left_subset:
                a.print_reveal_nested(end= " ")
            print_ln()

            print_ln("Right Subset (Depth: %s):", depth)
            for a in right_subset:
                a.print_reveal_nested(end=" ")
            print_ln()

            left_child_index = 2 * node_index + 1
            right_child_index = 2 * node_index + 2
            
            stack.append((left_child_index, left_subset, depth + 1))
            stack.append((right_child_index, right_subset, depth + 1))

            print_ln("Current status of the tree:")
            for a in kd_tree:
                a.print_reveal_nested(end=" ")
            print_ln()
    
    return kd_tree

def main():
    """
    Main function to handle client connections, receive data from clients, and store it in matrices.
    The function waits for all clients to connect, then receives N and K data points from each client.
    """
    # Start listening for client connections
    listen_for_clients(PORTNUM)
    print_ln("Listening for clients on base port %s", PORTNUM)

    # Arrays to store client socket IDs, client IDs, and connection status
    client_sockets = Array(num_clients, regint)
    client_ids = Array(num_clients, sint)
    seen = Array(num_clients, regint)
    seen.assign_all(0)

    # Matrices to store N and K data points from all clients
    n_dataset = Matrix(n_input_size * num_clients, dim_size, sint)
    k_dataset = Matrix(k_input_size * num_clients, dim_size, sint)

    # Loop until all clients have connected
    @do_while
    def client_connections():
        client_id, last = accept_client()
        print_ln("Client Connected: ID: %s | Last Flag: %s", client_id, last, print_secrets=True)
        
        # Ensure client ID is within the expected range
        @if_(client_id >= num_clients)
        def _():
            print_ln("Error: Client ID too high. Aborting.")
            crash()
        
        client_sockets[client_id] = client_id
        client_ids[client_id] = client_id
        seen[client_id] = 1
        return (sum(seen) < num_clients)
    
    print_ln("All clients have connected. Receiving data...")

    # Receive data from each connected client
    for i in range(num_clients):
        @if_(seen == 1)
        def receive_data():
            # Receive N data points
            print_ln("Receiving N from Client %s", client_ids[i], print_secrets=True)
            for j in range(n_input_size):
                rx = sint.receive_from_client(dim_size, client_sockets[i])
                n_dataset[(i * n_input_size) + j] = rx

            # Receive K data points
            print_ln("Receiving K from Client %s", client_ids[i], print_secrets=True)
            for k in range(k_input_size):
                rx = sint.receive_from_client(dim_size, client_sockets[i])
                k_dataset[(i * k_input_size) + k] = rx

    print_ln("Finished receiving data from all clients.")
    print_ln("Shuffling rows of K dataset.")
    k_dataset.secure_shuffle()

    print_ln("Starting the KD-Tree clustering.")
    tree_depth = int(ceil(log2(len(k_dataset))))
    kd_tree = build_tree(k_dataset, tree_depth)

    print_ln("KD-Tree Construction Complete. Revealing KD-Tree:")

    for i in range(len(kd_tree)):
        print_str("KD-Tree Node [%s]:", i)
        kd_tree[i].print_reveal_nested()

    # Close connections to all clients
    close_connections(num_clients)

# Run the main function
main()