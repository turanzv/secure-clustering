from Compiler.types import sint, regint, Array, MemValue
from Compiler.library import print_ln, do_while, for_range
from Compiler.util import if_else
from math import log2, ceil


# Base port number for client connections
PORTNUM = 14000

# Program arguments: test flag, number of clients, number of data points (n_size), 
# dimensions of data points (dim_size), and number of centroids (k_size)
test = program.args[0]
num_clients = int(program.args[1])
n_input_size = int(program.args[2])
dim_size = int(program.args[3])
k_input_size = int(program.args[4])

k_size = k_input_size * num_clients
n_size = n_input_size * num_clients

print_ln("Test: %s, N size: %s, Dim size: %s, K size: %s", test, n_input_size, dim_size, k_input_size)

def accept_client():
    """
    Accepts a connection from a client and retrieves the last flag from the socket.

    Returns:
        tuple: client_socket_id (regint), last (regint)
    """
    client_socket_id = accept_client_connection(PORTNUM)
    last = regint.read_from_socket(client_socket_id)
    return client_socket_id, last

def close_connections(number_clients):
    """
    Closes the connections for all clients.

    Args:
        number_clients (int): The number of clients connected.
    """
    @for_range(number_clients)
    def _(i):
        closeclientconnection(i)

def log2_sint(x: sint, bit_length: int) -> sint:
    """
    Compute the integer part of the log2 of an `sint` using bit decomposition.

    Args:
        x: The secret-shared secret integer input.
        bit_length: The bit length of the input (must be known or assumed).
    Returns:
        sint: the integer part of log2(x).
    """
    bits = x.bit_decompose()

    # initialize result as 0
    log2_result = sint(0)

    # Find the position of the most-significan bit set to 1
    @for_range(bit_length)
    def _(i):
        log2_result = i.if_else(bits[i], log2_result)
    
    return log2_result

def main():
    """
    Main function to handle client connections, receive data from clients, and store it in matrices.
    The function waits for all clients to connect, then receives N and K data points from each client.
    """
    # Start listening for client connections
    listen_for_clients(PORTNUM)
    print_ln("Listening for clients on base port %s", PORTNUM)

    # Arrays to store client socket IDs, client IDs, and connection status
    client_sockets = Array(num_clients, regint)
    client_ids = Array(num_clients, sint)
    seen = Array(num_clients, regint)
    seen.assign_all(0)

    # Matrices to store N and K data points from all clients
    n_dataset = Matrix(n_input_size * num_clients, dim_size, sint)
    k_dataset = Matrix(k_input_size * num_clients, dim_size, sint)

    # Loop until all clients have connected
    @do_while
    def client_connections():
        client_id, last = accept_client()
        print_ln("Client ID: %s, Last: %s", client_id, last, print_secrets=True)
        
        # Ensure client ID is within the expected range
        @if_(client_id >= num_clients)
        def _():
            print_ln("Client ID too high; aborting")
            crash()
        
        client_sockets[client_id] = client_id
        client_ids[client_id] = client_id
        seen[client_id] = 1
        return (sum(seen) < num_clients)
    
    print_ln("All clients have connected. Receiving data...")

    # Receive data from each connected client
    for i in range(num_clients):
        @if_(seen == 1)
        def receive_data():
            # Receive N data points
            print_ln("Receiving N from client %s", client_ids[i], print_secrets=True)
            for j in range(n_input_size):
                rx = sint.receive_from_client(dim_size, client_sockets[i])
                n_dataset[(i * n_input_size) + j] = rx
                # n_dataset[(i * n_size) + j].print_reveal_nested()
                # print_ln("N data row %s received from client %s", (i * n_size) + j, client_ids[i], print_secrets=True)

            # Receive K data points
            print_ln("Receiving K from client %s", client_ids[i], print_secrets=True)
            for k in range(k_input_size):
                rx = sint.receive_from_client(dim_size, client_sockets[i])
                k_dataset[(i * k_input_size) + k] = rx
                # k_dataset[(i * k_size) + k].print_reveal_nested()
                # print_ln("K data row %s received from client %s", (i * k_size) + k, client_ids[i], print_secrets=True)

    print_ln("Finished receiving data from all clients.")
    print_ln("Dataset received.")

    print_ln("Shuffling rows.")
    k_dataset.secure_shuffle()

    k_dataset.print_reveal_nested()

    print_ln("Starting the clustering.")
    print_ln("Sorting according to a dimension.")
    k_dataset.sort(key_indices=(2,), batcher=True)

    k_dataset.print_reveal_nested()

    print_ln("Building the KD-Tree from K. Greater than or equal to goes to the right")
    
    tree_depth = int(ceil(log2(k_size)))
    array_list = [Array(2<<length, sint).assign_all(sint(0)) for length in range(tree_depth)]
    
    print_ln("Depth: %s", tree_depth)

    for i in range(tree_depth):
        print_ln("Processing level %s", i)
        array_list[int(i)].print_reveal_nested()

    # @for_range(k_size)
    # def _(i):
    #     k_dataset[i].print_reveal_nested()
    # @for_range(tree_depth) # either a for_range or a do_while
    # def _(i):
    #     # sort according to a fun dimension

    # Close connections to all clients
    close_connections(num_clients)

# Run the main function
main()